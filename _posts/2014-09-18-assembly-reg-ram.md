---
layout: post
title: "Assembly 寄存器 （内存访问）"
description: "assembly reg ram"
category: Assembly
tags: [Assembly]
---
{% include JB/setup %}

###内存中字的存储
CPU用16位寄存器来存储一个字，高8位存放高位字节，低8位存放低位字节

内存单元是字节单元（一个单元存放一个字节）
0号单元是低地址单元，1号单元是高地址单元

概念：字单元，存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成

###DS和[address]
DS寄存器存放要访问的数据的段地址

------
将1000H（1000:0）中的数据读到al中

```
mov bx,1000H
mov ds,bx
mov al,[0]

```
8086CPU不支持将数据直接送入段寄存器的操作，ds是一个段寄存器

###字的传送
因为8086CPU是16位结构，有16根数据线，所以，可以一次性传送16位的数据，也就是说一次性传送一个字

###sub指令
`sub ax,9`

将寄存器AX中的数值减去9 （AX=AX-9）

###<span id="dataseg">数据段</span>
在编程时可以根据需要，将长度为N(N≤64KB)、地址连续、起始地址为16的倍数的内存单元当做专门存储数据的内存空间

###栈
LIFO(Last In First Out)后进先出

###CPU提供的栈机制
8086CPU的入栈和出栈操作都是以`字`为单位进行的

任意时刻，SS:SP指向栈顶元素

------
push ax 的执行，由两步完成：

1.SP=SP-2,SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；

2.将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶

------
pop ax 的执行过程和push ax刚好相反，由以下两步完成：

1.将SS:SP指向的内存单元出的数据送入ax中

2.SP=SP+2，SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶

###栈顶超界问题
8086CPU 不保证我们对栈的操作不会超界

###push、pop指令
push 寄存器	;将一个寄存器中的数据入栈

pop 寄存器	;出栈，用一个寄存器接收出栈的数据

push 段寄存器

pop 段寄存器

push 内存单元

pop 内存单元

------
push，pop 等栈操作指令，修改的只是SP。栈顶的变化范围最大为：`0~FFFFH`

###栈段
同[数据段](#dataseg)，只不过是当做栈空间来用

###小结
CS:IP 指向代码段

SS:SP 指向栈段

DS:[idata] 指向数据段（内存）